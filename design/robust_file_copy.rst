==========================
USB drive transfer process
==========================

Design goals:
-------------
* Don't modify the USB contents until data has been copied off and verified
* Do post-copy verification after flushing filesystem caches

Checkbox legend:
----------------
Progress is tracked with [x] checkboxes.  Most of the low-level implementation
is complete, but the step coroutines themselves need to be coded up and
tested - this is the progress that is being tracked.

* [x] Item complete and tested
* [-] Item code-complete but not tested
* [.] Item in-progress
* (no box) Item not wired up

Flow:
-----
The **setup** actor processes the command line options and figures out which
wav files to process or continue processing based in what progress directories
exist.  It builds an array of FileInfo objects which will be indexed by all
actors to process the files.

The actors get and send indexes into their input and output queues.  These
index into the array of FileInfo objects to coordinate processing.

Under each step header, a => flow line describes the inputs and outputs to the
current ``[actor]``, which is surrounded by square brackets.  Before
processing an index, the actor waits for all the inbound queues to have that
index ready for getting.  After processing the index, the actor puts that
index into all its outbound queues.  A terminal token is used to indicate that
there are no more items to process.

0. [x] (**initialize**): process command line and set up the step network

   a. [x] Verify all unit tests pass
   b. [x] Process and validate command line arguments
   c. [x] Generate list of source wav files
   d. [x] Load the instrument name from ``src/instrmnt.txt`` if it exists
   e. [x] If instrmnt.txt doesn't exist and --instrument wasn't specified,
      abort out.

1. [x] **setup**: *[global]* Determine wavs to process

   ``[setup] => listen,flacenc``

   a. [x] Create main progress directory if it doesn't already exist::

       mkdir .taketake.20211025-1802-Mon

   b. [x] Construct worklist of TransferInfo objects

   c. [x] Create src wav progress directories and symlinks that don't already exist for each wav, e.g. ``audio001.wav``::

       mkdir .taketake.20211025-1802-Mon/audio001.wav/
       symlink .taketake.20211025-1802-Mon/audio001.wav/.source.wav
            -> /absolute/path/to/source/audio001.wav

*Perform the following steps for each wav, assuming each non-src filename is
relative to the wav's* ``.taketake.$datestamp/$wavfilename`` *progress directory*

2. [x] **listen**: Speech to text

   ``setup => [listen] => autoname``

   **Skip this task if ``.audioinfo.json`` exists,
   filling in the guessed timestamp and duration into the TransferInfo instead.**

   a. [x] Extract playtime durations from each src wav file

   b. [x] Run speech to text, parse timestamp, construct filename guess

   c. [x] Dump audioinfo::

       echo $filename_guess > .audioinfo.json

3. [x] **reorder**: Reorder the source files for timestamping

   a. Buffer the file workunits until the first one with a successfully parsed
      audio timestamp is encountered.

   b. Emit the preceding workunits in reverse order

   c. Emit the first workunit found in the first step.

   d. Buffer and emit in forward-order the remaining workunits.

   If no workunit has a successfully parsed audio timestamp, emit them all in
   reverse order.

   Note forward order is the order as generated by the setup task.

4. [.] **prompt**: construct the filename guess

   ``listen => [prompt] => pargen``

   Determine timestamp:

   **If ``.filename_provided`` exists, set TransferInfo.timestamp from there
   and skip this task.**

   If AudioInfo.parsed_timestamp does not exist for the current file:

   a. Calculate the timestamp based on the preceding file if it exists::

       timestamp = prev.timestamp + prev.duration_s + delta

   b. Otherwise, if the prior file's timestamp doesn't exist, calculate the
      timestamp based on the next file if it exists::

       timestamp = next.timestamp - current.duration_s + delta

   c. Otherwise, if there is a next file and its timestamp doesn't exist, we
      must be using the "last", "ctime", "mtime", or timestamp"+" fallback and
      this must be the first file (token==0).  Use the fallback timestamp.

   d. Otherwise, if this is the last file, we must be using the "now" or
      timestamp"-" fallback.  Use the fallback timestamp.

   Finally:

   e. [x] Construct the guessed filename using the timestamp.

   f. [-] Dump the constructed filename to ``.filename_guess``::

       echo $filename_guess > .filename_guess

   g. Prompt for the final filename, checking the resulting timestamp:

      * Suggest TransferInfo.fname_guess
      * Parse out the timestamp from the ``$filename_provided``
      * Verify that the weekday matches that from the timestamp
      * Verify the timestamp is within a reasonable delta from the speech-recognized time
      * Verify the timestamp isn't in the future
      * If the verification fails, prompt the user to confirm or redo the
        filename

   h. Set TransferInfo.timestamp for the current file from the prompt results

   i. Dump the response filename to ``.filename_provided``::

       echo $filename_provided > .filename_provided

5. **flacenc**: Flac encode

   ``setup => [flacenc] => pargen``

   a. If ``.in_progress.flac`` exists, rename it to
      ``.interrupted-abandoned.$datestamp.flac``

   b. If ``.encoded.flac`` exists, skip to the final step in the task (decache
      the wav)

   c. Flac encode src wav into dest flac::

       encode src/audio001.wav => .in_progress.flac

   d. Rename encoded flac::

       rename .in_progress.flac -> .encoded.flac

   e. Decache the src wav, even if the flac already exists::

       fadvise DONTNEED src/audio001.wav

6. **pargen**: Rename and par2 dest flac file

   ``prompt,flacenc => [pargen] => cleanup``

   a. Unless ``$filename_provided.flac`` already exists,
      symlink from the final filename to the ``.encoded.flac``::

       symlink $filename_provided.flac -> .encoded.flac

   b. If ``$filename_provided.flac.vol*.par2`` exists:

       * if any of their sizes are 0, delete them::

           delete $filename_provided.flac.*par2

       * otherwise, skip the next step

   c. Create dest flac pars **(if interrupted, 0-sized files will be left)**::

       par2 create $filename_provided.flac

   f. Decache the dest flac and par2s::

       fadvise DONTNEED .encoded.flac *.par2

   g. Verify ``fincore .encoded.flac`` is 0

   h. Verify dest flac par2s::

       par2 verify $filename_provided.flac

7. **xdelta**: Xdelta check wavs

   ``All(flacenc) => [xdelta] => cleanup``

   a. Unless src wav no longer exists or if ``.xdelta`` exists, verify
      ``fincore src/.wav`` is 0 and diff the src and decoded wav files::

       flac -c -d .encoded.flac | xdelta3 -s src/.wav > .xdelta

   b. Check ``.xdelta`` for actual diffs

8. **cleanup**: Delete src wav and copy back flac

   ``All(xdelta),pargen => [cleanup] => finish``

   **Status of ``.taketake.$datestamp/$wavfilename``**::

        .source.wav -> /absolute/path/to/source/audio001.wav
        .audioinfo.json
        .filename_guess
        .filename_provided
        [.interrupted-abandoned.$datestamp.flac if any]
        .encoded.flac [was .in_progress.flac]
        $filename_provided.flac -> .encoded.flac
        $filename_provided.flac.vol0000+500.par2
        $filename_provided.flac.vol0500+499.par2
        .xdelta

   **Skip this task if src modification is disabled**

   a. Remove the source wav file::

       delete src/audio001.wav

   b. Copy flac file and par2s back to src if they each don't already exist
      (use .in_progress copies)::

       mkdir src/flacs
       copy .encoded.flac src/flacs/$filename_provided.flac
       update_mtime src/flacs/$filename_provided.flac
       copy
           $filename_provided.flac.vol0000+500.par2
           $filename_provided.flac.vol0500+499.par2
        -> src/flacs

   c. Decache the copied dest files

   d. par2 verified the copied dest files

   e. Move the final flac and par2 files into the dest directory::

       move .encoded.flac dest/$filename_provided.flac
       update_mtime src/flacs/$filename_provided.flac
       move $filename_provided.flac.*par2 dest/

   f. Remove the temporary dest directory contents except for the ``.source.wav`` symlink::

       rm .taketake.$datestamp/$wavfilename/* (except .source.wav)

   g. Update the transfer log on src and dest::

       echo "{timestamp} {src} -> {dest}" >> src/transfer.log >> dest/transfer.log

9. **finish**: *[global]* Wait for all processing to complete

   ``All(cleanup) => [finish]``

    a. Remove top-level progress dir ``.taketake.$datestamp``::

        rm .taketake.$datestamp/*/.source.wav
        rmdir .taketake.$datestamp/*
        rmdir .taketake.$datestamp

    b. Write the instrument name to ``src/instrmnt.txt`` if the file doesn't
       exist


Xdelta3 usage
-------------

Running xdelta with the stdout from flac decode
:::::::::::::::::::::::::::::::::::::::::::::::

From
https://docs.python.org/3.10/library/subprocess.html#replacing-shell-pipeline ::

    p1 = Popen(["dmesg"], stdout=PIPE)
    p2 = Popen(["grep", "hda"], stdin=p1.stdout, stdout=PIPE)
    p1.stdout.close()  # Allow p1 to receive a SIGPIPE if p2 exits.
    output = p2.communicate()[0]

Verifying two files are identical
:::::::::::::::::::::::::::::::::

When the files are identical, the VCDIFF data section length is 0,
and the only instruction is a copy of the entire file::

    $ xdelta3 printdelta robust_file_copy.rst.xdelta2    
    VCDIFF version:               0
    VCDIFF header size:           50
    VCDIFF header indicator:      VCD_APPHEADER 
    VCDIFF secondary compressor:  none
    VCDIFF application header:    robust_file_copy.rst//robust_file_copy.rst~/
    XDELTA filename (output):     robust_file_copy.rst
    XDELTA filename (source):     robust_file_copy.rst~
    VCDIFF window number:         0
    VCDIFF window indicator:      VCD_SOURCE VCD_ADLER32 
    VCDIFF adler32 checksum:      7BE74121
    VCDIFF copy window length:    22670
    VCDIFF copy window offset:    0
    VCDIFF delta encoding length: 16
    VCDIFF target window length:  22670
    VCDIFF data section length:   0
    VCDIFF inst section length:   4
    VCDIFF addr section length:   1
      Offset Code Type1 Size1 @Addr1 + Type2 Size2 @Addr2
      000000 019  CPY_0 22670 @0     

**Note** - The relevant lengths and copy sizes match the filesize.  All the
following properties should be verified::

    VCDIFF data section length:   0
    VCDIFF copy window offset:    0
    VCDIFF copy window length:    22670
    VCDIFF target window length:  22670
    000000 019  CPY_0 22670 @0

Livetrak support
----------------
Zoom multitrack recording format uses project directories.  To support copying
multiple project directories in one invokation:

* Add -r --recurse command line arg
* Add cmdargs.common_base
* When making/accessing the progressdir, subtract off the common_base from the
  source_wav

Smarter time guessing
---------------------

* Use src/transfer.txt's mtime as a lower bound
* Run speech recognition in parallel until we find the first file with a
  spoken timestamp
* Ask the user for fixing the timestamp on that one first:

  - Step.listen emits the token number for the first file with a timestamp
  - Step.listen then emits tokens in reverse order back through 0
  - Step.listen proceeds to emit the remaining token numbers in order

* If Step.prompt doesn't find a timestamp in the xinfo:

  - If xinfo[i-1] has a timestamp, guess
    xinfo[i-1].timestamp + xinfo[i-1].duration_s
    and add "+?" to the timestamp in the guessed filename to indicate the
    timestamp is likely too far in the past and some value should be added
    to it to get the real timestamp
  - Else if xinfo[i+1] has a timestamp, guess
    xinfo[i+1].timestamp - current_wav_xinfo.duration_s
    and add "-?" to the timestamp in the guessed filename to indicate the
    timestamp is too far in the future and some value should be subtracted
    from it to get the real timestamp
  - Else this must be i=0:

    . If src/transfer.txt exists, use its mtime as the guess, and append "+?"
    . Othewrise, use the current time minus the sum total of all durations
      involved in the transfer.

* When adding or subtracting timestamps, assume a 5 second minimum delta
  between recordings: When adding, add an extra 5.  When subtracting, subtract
  an extra five
